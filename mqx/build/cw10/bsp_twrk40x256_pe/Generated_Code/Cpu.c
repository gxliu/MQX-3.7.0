/** ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename  : Cpu.c
**     Project   : ProcessorExpert
**     Processor : MK40X256VMD100
**     Component : MK40N512MD100
**     Version   : Component 01.156, Driver 01.02, CPU db: 3.00.001
**     Datasheet : K40P144M100SF2RM, Rev. 3, 4 Nov 2010
**     Compiler  : CodeWarrior ARM C Compiler
**     Date/Time : 2011-03-28, 23:29, # CodeGen: 31
**     Abstract  :
**
**     Settings  :
**
**     Contents  :
**         No public methods
**
**     Copyright : 1997 - 2010 Freescale Semiconductor, Inc. All Rights Reserved.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/

/* MODULE Cpu. */
#include "MQX1.h"
#include "GPIO1.h"
#include "DA1.h"
#include "TRG.h"
#include "WDog1.h"
#include "PWM.h"
#include "PE_Types.h"
#include "PE_Error.h"
#include "PE_Const.h"
#include "IO_Map.h"
#include "Events.h"
#include "Cpu.h"

/*
** ===================================================================
**     Method      :  __pe_initialize_hardware (component MK40N512MD100)
**
**     Description :
**         Initializes the whole system like timing, external bus, etc.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/

/*** !!! Here you can place your own code using property "User data declarations" on the build options tab. !!! ***/

void __pe_initialize_hardware(void)
{

  /*** !!! Here you can place your own code before PE initialization using property "User code before PE initialization" on the build options tab. !!! ***/

  /*** ### MK40X256VMD100 "Cpu" init code ... ***/
  /*** PE initialization code after reset ***/
  /* SIM_SCGC6: RTC=1 */
  SIM_SCGC6 |= (uint32_t)0x20000000UL;                       
  if ((RTC_CR & RTC_CR_OSCE_MASK) == 0u) { /* Only if the OSCILLATOR is not already enabled */
    /* RTC_CR: SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
    RTC_CR &= (uint32_t)~0x3C00UL;                      
    /* RTC_CR: OSCE=1 */
    RTC_CR |= (uint32_t)0x0100UL;                       
    /* RTC_CR: CLKO=1 */
    RTC_CR |= (uint32_t)0x0200UL;                       
  }
  /* Disable the WDOG module */
  /* WDOG_UNLOCK: WDOGUNLOCK=0xC520 */
  WDOG_UNLOCK = (uint16_t)0xC520U;     /* Key 1 */
  /* WDOG_UNLOCK : WDOGUNLOCK=0xD928 */
  WDOG_UNLOCK  = (uint16_t)0xD928U;    /* Key 2 */
  /* WDOG_STCTRLH: ??=0,DISTESTWDOG=0,BYTESEL=0,TESTSEL=0,TESTWDOG=0,??=0,STNDBYEN=1,WAITEN=1,STOPEN=1,DBGEN=0,ALLOWUPDATE=1,WINEN=0,IRQRSTEN=0,CLKSRC=1,WDOGEN=0 */
  WDOG_STCTRLH = (uint16_t)0x01D2U;                  
  /* System clock initialization */
  /* Switch to FBE Mode */
  /* OSC_CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
  OSC_CR = (uint8_t)0x80U;                             
  /* SIM_SOPT2: MCGCLKSEL=0 */
  SIM_SOPT2 &= (uint8_t)~(uint8_t)0x01U;                           
  /* MCG_C2: ??=0,??=0,RANGE=2,HGO=0,EREFS=1,LP=0,IRCS=0 */
  MCG_C2 = (uint8_t)0x24U;                             
  /* MCG_C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
  MCG_C1 = (uint8_t)0x9AU;                             
  /* MCG_C4: DMX32=0,DRST_DRS=0 */
  MCG_C4 &= (uint8_t)~(uint8_t)0xE0U;                           
  /* MCG_C5: ??=0,PLLCLKEN=0,PLLSTEN=0,PRDIV=3 */
  MCG_C5 = (uint8_t)0x03U;                             
  /* MCG_C5: PLLCLKEN=1 */
  MCG_C5 |= (uint8_t)0x40U;            /* Enable the PLL */
  /* MCG_C6: LOLIE=0,PLLS=0,CME=0,VDIV=0 */
  MCG_C6 = (uint8_t)0x00U;                             
  while((MCG_S & MCG_S_OSCINIT_MASK) == 0x00U) { /* Check that the oscillator is running */
  }
  while((MCG_S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
  }
  while((MCG_S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
  }
  /* Switch to PBE Mode */
  /* OSC_CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
  OSC_CR = (uint8_t)0x80U;                             
  /* SIM_SOPT2: MCGCLKSEL=0 */
  SIM_SOPT2 &= (uint8_t)~(uint8_t)0x01U;                           
  /* MCG_C1: CLKS=2,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
  MCG_C1 = (uint8_t)0x9AU;                             
  /* MCG_C2: ??=0,??=0,RANGE=2,HGO=0,EREFS=1,LP=0,IRCS=0 */
  MCG_C2 = (uint8_t)0x24U;                             
  /* MCG_C5: ??=0,PLLCLKEN=0,PLLSTEN=0,PRDIV=3 */
  MCG_C5 = (uint8_t)0x03U;                             
  /* MCG_C6: LOLIE=0,PLLS=1,CME=0,VDIV=0 */
  MCG_C6 = (uint8_t)0x40U;                             
  while((MCG_S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
  }
  /* Switch to PEE Mode */
  /* OSC_CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
  OSC_CR = (uint8_t)0x80U;                             
  /* SIM_SOPT2: MCGCLKSEL=0 */
  SIM_SOPT2 &= (uint8_t)~(uint8_t)0x01U;                           
  /* MCG_C1: CLKS=0,FRDIV=3,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
  MCG_C1 = (uint8_t)0x1AU;                             
  /* MCG_C2: ??=0,??=0,RANGE=2,HGO=0,EREFS=1,LP=0,IRCS=0 */
  MCG_C2 = (uint8_t)0x24U;                             
  /* MCG_C5: ??=0,PLLCLKEN=0,PLLSTEN=0,PRDIV=3 */
  MCG_C5 = (uint8_t)0x03U;                             
  /* MCG_C6: LOLIE=0,PLLS=1,CME=0,VDIV=0 */
  MCG_C6 = (uint8_t)0x40U;                             
  while((MCG_S & 0x0CU) != 0x0CU) {    /* Wait until output of the PLL is selected */
  }
  while((MCG_S & MCG_S_LOCK_MASK) == 0x00U) { /* Wait until locked */
  }
  /* SIM_CLKDIV1: OUTDIV1=0,OUTDIV2=0,OUTDIV3=0,OUTDIV4=1,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
  SIM_CLKDIV1 = (uint32_t)0x00010000UL; /* Update system prescalers */
  /* SIM_CLKDIV2: USBDIV=0,USBFRAC=0 */
  SIM_CLKDIV2 &= (uint32_t)~0x0FUL;    /* Update USB clock prescalers */
  /* SIM_SOPT2: PLLFLLSEL=1 */
  SIM_SOPT2 |= (uint32_t)0x00010000UL; /* Select PLL as a clock source for various peripherals */
  /* SIM_SOPT1: OSC32KSEL=1 */
  SIM_SOPT1 |= (uint32_t)0x00080000UL; /* RTC oscillator drives 32 kHz clock for various peripherals */
  /* SIM_SCGC5: PORTE=1,PORTC=1,PORTA=1 */
  SIM_SCGC5 |= (uint32_t)0x2A00UL;     /* Enable clock gate for ports to enable pin routing */
  /*** End of PE initialization code after reset ***/

  /*** !!! Here you can place your own code after PE initialization using property "User code after PE initialization" on the build options tab. !!! ***/

}

/*
** ===================================================================
**     Method      :  Cpu_SetBASEPRI (component MK40N512MD100)
**
**     Description :
**         This method sets the BASEPRI core register.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
/*lint -save  -e586 -e950 Disable MISRA rule (2.1,1.1) checking. */
#ifdef _lint
  #define Cpu_SetBASEPRI(Level)  /* empty */
#else
asm void Cpu_SetBASEPRI(register uint32_t Level) {
  MSR BASEPRI,R0;
  MOV PC,LR
}
#endif
/*lint -restore Enable MISRA rule (2.1,1.1) checking. */

/*
** ===================================================================
**     Method      :  PE_low_level_init (component MK40N512MD100)
**
**     Description :
**         Initializes beans and provides common register initialization. 
**         The method is called automatically as a part of the 
**         application initialization code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void PE_low_level_init(void)
{
  /* PORTA_PCR4: ISF=0,MUX=7 */
  PORTA_PCR4 = (uint32_t)((PORTA_PCR4 & (uint32_t)~0x01000000UL) | (uint32_t)0x0700UL);
  /* PORTA_PCR2: ISF=0,MUX=7 */
  PORTA_PCR2 = (uint32_t)((PORTA_PCR2 & (uint32_t)~0x01000000UL) | (uint32_t)0x0700UL);
  /* PORTA_PCR1: ISF=0,MUX=7 */
  PORTA_PCR1 = (uint32_t)((PORTA_PCR1 & (uint32_t)~0x01000000UL) | (uint32_t)0x0700UL);
  /* PORTA_PCR0: ISF=0,MUX=7 */
  PORTA_PCR0 = (uint32_t)((PORTA_PCR0 & (uint32_t)~0x01000000UL) | (uint32_t)0x0700UL);
  /* PORTA_PCR3: ISF=0,MUX=7 */
  PORTA_PCR3 = (uint32_t)((PORTA_PCR3 & (uint32_t)~0x01000000UL) | (uint32_t)0x0700UL);
  /* PORTA_PCR5: ISF=0,MUX=7 */
  PORTA_PCR5 = (uint32_t)((PORTA_PCR5 & (uint32_t)~0x01000000UL) | (uint32_t)0x0700UL);
  /* SIM_SOPT6: RSTFLTEN=0,RSTFLTSEL=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
  SIM_SOPT6 = (uint32_t)0x00UL;        /* Set reset pin filter */
  /* Initialization of the PMC module */
  /* PMC_LVDSC1: LVDACK=1,LVDIE=0,LVDRE=1,LVDV=0 */
  PMC_LVDSC1 = (uint8_t)((PMC_LVDSC1 & (uint8_t)~(uint8_t)0x23U) | (uint8_t)0x50U);
  /* PMC_LVDSC2: LVWACK=1,LVWIE=0,LVWV=0 */
  PMC_LVDSC2 = (uint8_t)((PMC_LVDSC2 & (uint8_t)~(uint8_t)0x23U) | (uint8_t)0x40U);
  /* PMC_REGSC: TRAMPO=0,??=0,BGBE=0 */
  PMC_REGSC &= (uint8_t)~(uint8_t)0x13U;                           
  /* MC_PMPROT: ??=0,??=0,AVLP=0,ALLS=0,??=0,AVLLS3=0,AVLLS2=0,AVLLS1=0 */
  MC_PMPROT = (uint8_t)0x00U;          /* Setup Power mode protection register */
  /* Common initialization of the CPU registers */
  /* NVICIP20: PRI20=0 */
  NVICIP20 = (uint8_t)0x00U;                             
}

/* END Cpu. */

/*
** ###################################################################
**
**     This file was created by Processor Expert 5.00 [04.48]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
